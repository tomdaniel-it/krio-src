module.exports = function(bZO) {
    bZO.StrippedLambertMaterial = function(bZP) {
        let bZS = new bZO.ShaderMaterial({
            'name': 'lambert-stripped',
            'uniforms': bZO.UniformsUtils.merge([bZO.ShaderLib.lambert.uniforms]),
            'lights': true,
            'fog': true,
            'vertexShader': '\x0a#define LAMBERT\x0avarying vec3 vLightFront;\x0avarying vec3 vIndirectFront;\x0a#ifdef DOUBLE_SIDED\x0a    varying vec3 vLightBack;\x0a    varying vec3 vIndirectBack;\x0a#endif\x0a#include <common>\x0a#include <uv_pars_vertex>\x0a#include <uv2_pars_vertex>\x0a// #include <envmap_pars_vertex>\x0a#include <bsdfs>\x0a#include <lights_pars_begin>\x0a#include <color_pars_vertex>\x0a#include <fog_pars_vertex>\x0a// #include <morphtarget_pars_vertex>\x0a// #include <skinning_pars_vertex>\x0a#include <shadowmap_pars_vertex>\x0a// #include <logdepthbuf_pars_vertex>\x0a// #include <clipping_planes_pars_vertex>\x0avoid main() {\x0a    #include <uv_vertex>\x0a    #include <uv2_vertex>\x0a    #include <color_vertex>\x0a    #include <beginnormal_vertex>\x0a    // #include <morphnormal_vertex>\x0a    // #include <skinbase_vertex>\x0a    // #include <skinnormal_vertex>\x0a    #include <defaultnormal_vertex>\x0a    #include <begin_vertex>\x0a    // #include <morphtarget_vertex>\x0a    // #include <skinning_vertex>\x0a    #include <project_vertex>\x0a    // #include <logdepthbuf_vertex>\x0a    // #include <clipping_planes_vertex>\x0a    #include <worldpos_vertex>\x0a    // #include <envmap_vertex>\x0a    #include <lights_lambert_vertex>\x0a    #include <shadowmap_vertex>\x0a    #include <fog_vertex>\x0a}\x0a',
            'fragmentShader': '\x0auniform vec3 diffuse;\x0auniform vec3 emissive;\x0auniform float opacity;\x0a\x0avarying vec3 vLightFront;\x0avarying vec3 vIndirectFront;\x0a\x0a#ifdef DOUBLE_SIDED\x0a    varying vec3 vLightBack;\x0a    varying vec3 vIndirectBack;\x0a#endif\x0a\x0a\x0a#include <common>\x0a#include <packing>\x0a// #include <dithering_pars_fragment>\x0a#include <color_pars_fragment>\x0a#include <uv_pars_fragment>\x0a#include <uv2_pars_fragment>\x0a#include <map_pars_fragment>\x0a// #include <alphamap_pars_fragment>\x0a#include <aomap_pars_fragment>\x0a#include <lightmap_pars_fragment>\x0a#include <emissivemap_pars_fragment>\x0a// #include <envmap_pars_fragment>\x0a#include <bsdfs>  // Shading functions\x0a#include <lights_pars_begin>\x0a#include <fog_pars_fragment>\x0a#include <shadowmap_pars_fragment>\x0a#include <shadowmask_pars_fragment>\x0a// #include <specularmap_pars_fragment>\x0a// #include <logdepthbuf_pars_fragment>\x0a// #include <clipping_planes_pars_fragment>\x0a\x0avoid main() {\x0a\x0a    // #include <clipping_planes_fragment>\x0a\x0a    vec4 diffuseColor = vec4( diffuse, opacity );\x0a    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\x0a    vec3 totalEmissiveRadiance = emissive;\x0a\x0a    // #include <logdepthbuf_fragment>\x0a    #include <map_fragment>\x0a    #include <color_fragment>\x0a    // #include <alphamap_fragment>\x0a    #include <alphatest_fragment>\x0a    // #include <specularmap_fragment>\x0a    #include <emissivemap_fragment>\x0a\x0a    // accumulation\x0a    reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\x0a\x0a    #ifdef DOUBLE_SIDED\x0a\x0a        reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\x0a\x0a    #else\x0a\x0a        reflectedLight.indirectDiffuse += vIndirectFront;\x0a\x0a    #endif\x0a\x0a    #include <lightmap_fragment>\x0a\x0a    reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\x0a\x0a    #ifdef DOUBLE_SIDED\x0a\x0a        reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\x0a\x0a    #else\x0a\x0a        reflectedLight.directDiffuse = vLightFront;\x0a\x0a    #endif\x0a\x0a    reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\x0a\x0a    // modulation\x0a    #include <aomap_fragment>\x0a\x0a    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\x0a\x0a    // #include <envmap_fragment>\x0a\x0a    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\x0a\x0a    // #include <tonemapping_fragment>\x0a    // #include <encodings_fragment>\x0a    #include <fog_fragment>\x0a    #include <premultiplied_alpha_fragment>\x0a    // #include <dithering_fragment>\x0a}\x0a    '
        });
        Object.assign(bZS, new bZO.MeshLambertMaterial(bZP));
        bZS.isMeshLambertMaterial = true;
        bZS.setValues(bZP);
        return bZS;
    };
};
